---
layout: post
title:  "2018年底面试总结"
date:   2018-11-23 22:26:12 +0800
categories: 技术--android
---


# 快手
面试第一站快手，HR面试邀约来的很快，因为之前有面试过快手的经验，快手面试更加考察面试者的思维能力，说的明白点就是，算法考的比较多，我也比较偏爱这些，面试我的小哥，看着性格跟我比较像，从后续的交流感觉彼此还是有很多类似的地方，在简单的寒暄之后，正式进入正题，面试官随机挑选简历上的项目，随机找个问题提出疑问，这部分因人而异没啥通用的规律，先说算法题，打印一棵二叉树，其实并不是很难，简单的一个中序遍历就搞定了，接下来重点来了，层次遍历一棵二叉树（我不爱刷题，这题还是第一次遇到），关于这题我的思维过程是这样的，涉及到二叉树，常用的解法：广度优先遍历、深度优先遍历，由于是层次遍历，显然广度优先遍历更加适合嘛，问题的难点怎么知道在哪里换行呢？最先想到的是，想办法在遍历的时候知道行号的信息，在行号发生改变的时候打印换行符，可是觉得有点麻烦。我就手动的尝试解决这个问题（随便找一个二叉树，我人肉层次遍历这棵树，观察我是自己是如何解决这个问题的，能不能总结出啥规律），惊奇的发现，要是使用广度优先遍历，每层次的节点非常自然的有一个集体入队和出队的过程，如果我在一个层次结束完了之后就换行，不就可以解决了这个问题吗？所以我选择了使用两个队列来进行广度优先搜索，伪码如下：

```
    public void levelPrint(Node root){
       if (root==null){
         return;
       }
       Queue parent=new Queue();
       parent.enqueue(root);
       Queue child=new Queue();
       while(!parent.isEmpty()){
          Node p=parent.dequeue();
          print(p.value)
          //左右子节点入队
          if(p.left!=null)
          child.enqueue(p.left);
          if(p.right!=null)
          child.enqueue(p.right);
			
			if(parent.isEmpty()){
			  //当前层次遍历完毕
			  parent=child;
			  child.clear();
			  //换行
			  print("\n")
			}
       }
       
    }
```
遍历的算法复杂度为O(n),空间复杂度O(n)，解决问题。

面试过程中的一些其他的问题，比如如何统计线上APP在启动一秒内，有多少个线程启动，这可能还是一个比较常见的监控数据，问题简化理解就是有多少个```Thread```的```start```方法执行，可能也是和我的经历有关系，我之前做过比较多的切面编程（AOP），第一件事就是想到使用切面进行日志上报，面试官也是做个相关的工作，在确认了需求之后，开始说出我的想法，但是由此会导致一个问题，日志上报的函数肯定存在这个多线程访问的问题，如何加锁成为了焦点。
直接一个关键字，``synchronized``未免太过于简单粗暴，而且基本上会有性能问题，所以需要换个方式，由于线程的个数可能比较多，所以一个锁极有可能导致性能问题，在面试官的一步步追问下，必然要使用多个对象锁来解决并发问题，面试官提醒我可以个手机CPU的核数相关，其实我是没有了解这块，所以对于对象锁的个数，我把握不是很好，一番沟通之后就创建了和CPU核数相同的对象，用来保存需要搜集的线程相关信息，思路没问题之后开始写代码：

```
    List<HashMap> reportMessage=new HashMap(CORE_SIZE);
    public void log(HashMap message){
       int index=System.currentTimeMillis()% CORE_SIZE;
       synchronized(reportMessage.get(index)){
         reportMessage.get(index).putALL(message);
       }
       
    }
```
基础的代码就是这样，然后他跟我说有问题，index的选取和时间相关，多线程很有可能是同时运行的，这块我一开始是准备用随机数的，但是记得生成随机数的性能开销比较大，就选择了时间作为随机数，事实证明面试官是正确的。

然后继续问我，``List<HashMap>``如何上报给后台，其实就是多个Hashmap的合并问题，其实并不是很难，但是我在书写的过程中，没有对Map中取出的值进行判空，就直接进行合并，面试官果断的指出可能存在的NPE，羞愧了呀，可能是时间的原因后续没有在继续下去，面试进行了整整两个小时，到了饭点，还去快手的食堂蹭了饭，感觉挺不错，菜品很丰富，免费的午餐呀！

过了几天开始了二面，二面基本上在跟我聊项目，聊APP的框架，刚巧在创业公司一个APP从0开始，我对框架的重要性有些小小的体会，当我提到MVP的时候，我把复杂繁琐的逻辑全部交给了P层做，尽量保证了V层的干净和整洁，但是也遇到了一些内存泄漏等问题，跟他讲解我是如何解决的，顺势问了问快手的框架结构，他们使用的是MVPs，不知道快手愿不愿意分享出来，细节不讲解太多，可以理解成为MVP的一个变种，他表示业务逻辑才是最复杂的，最难搞的是V层，这个层次包含了太多了交互和业务逻辑，我猛然想到，在创业公司APP的交互还是比较简单的，如果当那天一个V层的复杂类似美团的首页、快手的首页这样，V层也是无法避免变得异常臃肿，一番交流下来，深深的被他身上隐射的技术力量折服。

一番娱乐的交流之后，进入了HR面试，HR就是对我的经历比较感兴趣，把我聊嗨了，大学时候的事情都说出来了，突然才觉得我毕业那么多年了，想当年和松哥从西安南下深圳，在火车上坐了36个小时，路上还有一个可爱的小朋友和我们一路。

说多了哈，HR结束后，告诉我还有一轮总监面，面试流程让我触不及防。天色已晚当天就回家了，然后开始了我三征快手的旅程。总监面我还是比较虚的，感觉来历很大，我不知道会面试我啥，心里很忐忑，又是一轮开始准备，准备的过程中才发现，面试最好的准备是在于平时的积累，临时抱佛脚很容易露馅，禁不住三连问的。直到我见到三面之后，才发现是个老熟人（之前来快手面试过，三面是同一个人），想起一年前他给我做的面试算法题，辛酸史呀，当时出的题目历历在目，求一个字符串的全子集，比如说：字符串是“abc”，需要输出“a,b,c,ab,ac,bc,abc",我清楚的记得这个算法当时我写了快两页A4纸，用了非递归的方式，写的我心力交瘁，面试写过最长的算法，没有之一。

快手面试基本结束，总体感觉比较偏重随机应变、算法和实际处理问题的能力，比如一面面试官的环环相扣的问题，可能就是他之前解决的某个线上问题，面试给我的感觉很好。

下片分析今日头条