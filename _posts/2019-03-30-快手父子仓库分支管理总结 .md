---
layout: post
title:  "工作总结"
date:   2019-04-13 15:26:12 +0800
categories: 工作
---


# 概述
  我来到快手的时候刚好赶上快手组件化的浪潮，立马投身于快手的组件化建设，最开始的时候各种思路基本是仿照美团的组件化建设模式（在这里不得不说一句，美团的技术沉淀真的是挺不错的），然后我就是开始轰轰烈烈的拆分代码，照猫画虎，可却渐渐的走了样...

# 背景
   快手APP在组件化之前就已经开始对代码进行了不同程度的梳理，内部的代码相当一部分已经按照需求分层，形成了三横四列的结构，一横就代表一层（快手的代码逻辑上分为三层：业务层、业务通用层、业务无关层），四列代表了快手的四条业务线，然后组件就开始于切分三横四列这些模块，
   很快我们就完成了模块化的第一部分工作，把拆分的仓库进行相关负责人的划分（这部分参考美团的设计方案，每个库都有特定的人负责），然后我们就开始上线，上线之后的下一步尼？就是被吐槽死，最直接的改变就是大家修改代码成本增大了好多，
   以前只需要修改一个类就提交，拆分之后就需要好多步，遭遇了大家相当大的吐槽和阻力，但是我们知道开发模式的转变需要一段时间来适应。

   正如上文所说，粗暴的完成代码拆分之后，我们需要完成下一步--父子分支的管理，在这一块老东家美团又给我起了一个很好的带头作用，深深刻在我心中的三段式：master-stage-develop三段式分支开发方式，
   我第一个想到的就是效仿这个分支管理模式，然而快手这边一直使用的是：master---N个release的模式，两种模式的本质其实是类似的，三段式的分支开发流程是这样：需求加到develop分支，develop开发完毕发灰度，同时把
   代码合并到stage分支，stage分支只能修改bug，stage分支修改灰度bug之后，合并到master，同时stage合回develop，这个流程比较清晰，简洁易懂，设计这个模式的人一定是一个优秀的程序员，但是如果当多
   个版本在同时开发的时候，这个模式就会略显的捉襟见肘，因为大家养成的习惯就是代码想develop提交很容易造成，两个版本需求混乱。

   再回来聊聊master-N个release分支，这个分支模式很适合多个版本同时开发，一个分支承载从需求开发、bug修改、灰度等诸多功能，会显得没有三段式职责那么清晰，对代码review和开发者本身要求更高一些。个人还是喜欢三段式多一些，但是三段式的开发模式
   在多版本并行开发的时候暴露的问题太严重，甚至可能会夸张的退化到master--N个release分支的模式，经过我们也对比各大公司的分支管理情况，我们还是选择了master--N个release，为啥？因为对大家的学习成本小。

# 问题
  采取了master-N个release分支管理模式，带来的最大的一个痛点就是release分支太多了，如果人肉手动的把子库的分支和主APP分支保持一致，这个必然要疯，工作量太多而且很不控（这也是我为什么喜欢三段式的原因
  ，很简单，三段式之后子仓库只需要三个分支和父仓库完全保持一致），而master-N个release分支管理模式，需要子库也有N个release和父仓库对应（如果父子仓库分支不对应会有什么问题？分支不对应会导致release-N分支加载着在子库Release-N-1或者Release-N+1的代码
  这必然不是你想要的），父子仓库分支对应就造成一个巨无霸的坑，如何做到父子仓库分支严格的意义上的对应？

# 解决
  上述问题，可以在父仓库创建release分支的时候，同时给所有子库创建分支，在父仓库merge release分支到master的时候，自仓库也需要同步操作。诸如这类重复性操作，还是全部交给自动化脚本来做这是吧。
  分支管理的借助于脚本，暂时算是勉强完成，接下来就是子仓库不同分支打出aar的版本和父仓库版本号保持相关性，比如说父仓库的版本是6.1.1版本，那么自仓库的版本可以为：6.1.1.xx，增加一个小版本号来
  区分不同的版本，所以父子仓库的版本号升级的工作也应该是同步操作
  
到此，结合快手之前的分支管理风格，以及才分子库的代码分支管理就这样的告一段落，下部分内容，我们聊聊快手是如何优化打包速度的